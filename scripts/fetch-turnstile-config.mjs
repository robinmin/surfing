#!/usr/bin/env node
/**
 * Fetch Turnstile Application Configuration
 *
 * This script fetches application configuration from the Turnstile API
 * and generates a TypeScript file with the configuration.
 *
 * The generated file is used at build time to provide type-safe
 * configuration without runtime overhead.
 *
 * Environment Variables Required:
 * - PUBLIC_TURNSTILE_API_URL: Turnstile API base URL
 * - PUBLIC_APPLICATION_ID: Application ID (e.g., 'surfing')
 * - TURNSTILE_BUILD_TOKEN: Build token for authentication (optional in dev)
 *
 * @example
 * ```bash
 * node scripts/fetch-turnstile-config.mjs
 * ```
 */

const TURNSTILE_API_URL = process.env.PUBLIC_TURNSTILE_API_URL
const APPLICATION_ID = process.env.PUBLIC_APPLICATION_ID
const BUILD_TOKEN = process.env.TURNSTILE_BUILD_TOKEN
const OUTPUT_FILE = 'src/lib/turnstile/generated.config.ts'

// Validate required environment variables
if (!TURNSTILE_API_URL) {
  console.error('âŒ Error: PUBLIC_TURNSTILE_API_URL environment variable is not set.')
  console.error('   Set it in your .env file or environment.')
  process.exit(1)
}

if (!APPLICATION_ID) {
  console.error('âŒ Error: PUBLIC_APPLICATION_ID environment variable is not set.')
  console.error('   Set it in your .env file or environment.')
  process.exit(1)
}

async function fetchConfig() {
  const url = `${TURNSTILE_API_URL}/api/config/app/${APPLICATION_ID}`
  console.log(`ğŸ” Fetching config from: ${url}`)

  const headers = {
    'Content-Type': 'application/json',
  }

  // Add build token if available
  if (BUILD_TOKEN) {
    headers['Authorization'] = `Bearer ${BUILD_TOKEN}`
  }

  const response = await fetch(url, { headers })

  if (!response.ok) {
    if (response.status === 404) {
      console.error(`âŒ Error: Application '${APPLICATION_ID}' not found in Turnstile.`)
      console.error('   Make sure the application is configured in Turnstile.')
    } else {
      console.error(`âŒ Error: Failed to fetch config. Status: ${response.status}`)
      console.error(`   URL: ${url}`)
    }
    process.exit(1)
  }

  const config = await response.json()

  if (!config.success || !config.data) {
    console.error('âŒ Error: Invalid response from Turnstile API')
    console.error('   Response:', config)
    process.exit(1)
  }

  const data = config.data

  // Validate required fields
  if (!data.subscription || !data.checkout) {
    console.error('âŒ Error: Invalid configuration received from Turnstile API')
    console.error('   Missing subscription or checkout configuration')
    process.exit(1)
  }

  console.log('âœ… Configuration fetched successfully')

  // Generate TypeScript file
  const ts = `// AUTO-GENERATED by scripts/fetch-turnstile-config.mjs
// DO NOT EDIT MANUALLY - This file is regenerated at build time
//
// This file contains application configuration fetched from Turnstile API
// at build time. Changes to the configuration should be made in Turnstile
// and this script will be run again during the next build.

import type { SubscriptionConfig } from '@turnstile/client';

/**
 * Turnstile Application Configuration
 *
 * This configuration was fetched from Turnstile API at build time.
 * It contains subscription roles, tiers, and price IDs for this application.
 */
export const TURNSTILE_APP_ID = '${data.applicationId}';
export const TURNSTILE_APP_NAME = '${data.name}';

/**
 * Subscription Configuration
 *
 * Defines role hierarchy, role-to-tier mappings, and default role for
 * access control checks.
 */
export const SURFING_SUBSCRIPTION_CONFIG: SubscriptionConfig = ${JSON.stringify(data.subscription, null, 2)};

/**
 * Stripe Price IDs
 *
 * Price IDs for different tiers and billing cycles. These are used to
 * create checkout sessions in Stripe.
 */
export const PRICE_IDS = ${JSON.stringify(data.checkout.priceIds, null, 2)};

/**
 * Zitadel Configuration
 *
 * Zitadel connection details for this application.
 */
export const ZITADEL_CONFIG = ${JSON.stringify(data.zitadel || {}, null, 2)};
`

  // Write to file
  const fs = await import('fs')
  const path = await import('path')

  const outputPath = path.resolve(process.cwd(), OUTPUT_FILE)
  const outputDir = path.dirname(outputPath)

  // Ensure directory exists
  await fs.promises.mkdir(outputDir, { recursive: true }).catch(() => {
    // Directory already exists
  })

  await fs.promises.writeFile(outputPath, ts, 'utf-8')

  console.log(`âœ… Generated configuration file: ${OUTPUT_FILE}`)
  console.log(`   Application: ${data.name} (${data.applicationId})`)
  console.log(
    `   Roles configured: ${Object.keys(data.subscription.roleToTierMapping || {}).join(', ')}`
  )
}

// Run the fetch
fetchConfig().catch((error) => {
  console.error('âŒ Fatal error:', error.message)
  process.exit(1)
})
