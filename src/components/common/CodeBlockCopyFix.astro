---
// Fix for astro-expressive-code copy button issues
// This script patches the copy functionality to prevent race conditions
---

<script>
  // Wait for the original expressive-code script to load
  document.addEventListener('DOMContentLoaded', () => {
    // Track buttons that are currently processing to prevent race conditions
    const processingButtons = new WeakSet();

    function fallbackCopy(text: string): boolean {
      // Check if execCommand is available (for older browsers)
      const doc = document as any;
      const execCommandMethod = 'execCommand';

      if (typeof doc[execCommandMethod] !== 'function') {
        return false;
      }

      const pre = document.createElement('pre');
      Object.assign(pre.style, {
        opacity: '0',
        pointerEvents: 'none',
        position: 'absolute',
        overflow: 'hidden',
        left: '0',
        top: '0',
        width: '20px',
        height: '20px',
        webkitUserSelect: 'auto',
        userSelect: 'all',
      });
      pre.ariaHidden = 'true';
      pre.textContent = text;
      document.body.appendChild(pre);

      const range = document.createRange();
      range.selectNode(pre);
      const selection = getSelection();
      if (!selection) {
        document.body.removeChild(pre);
        return false;
      }

      selection.removeAllRanges();
      selection.addRange(range);

      let success = false;
      try {
        // Use string literal to avoid TypeScript deprecation warning
        // This fallback is only for older browsers where Clipboard API is unavailable
        success = doc[execCommandMethod]('copy');
      } finally {
        selection.removeAllRanges();
        document.body.removeChild(pre);
      }
      return success;
    }

    function getOriginalCodeText(button: HTMLButtonElement): string {
      // Try to get the original code from the DOM instead of data-code attribute
      // This fixes the issue where expressive-code strips comments from bash/shell
      const expressiveCodeElement = button.closest('.expressive-code');
      if (!expressiveCodeElement) {
        // Fallback to data-code if no expressive-code parent found
        return button.dataset.code?.replace(/\u007f/g, '\n') || '';
      }

      const preElement = expressiveCodeElement.querySelector('pre[data-language]');
      if (!preElement) {
        // Fallback to data-code if no pre element found
        return button.dataset.code?.replace(/\u007f/g, '\n') || '';
      }

      // Get the original text content from the pre element
      let originalText = (preElement as HTMLElement).innerText || preElement.textContent || '';

      // Clean up the text while preserving comments
      originalText = originalText
        .replace(/\u007f/g, '\n') // Replace any literal \u007f with actual newlines
        .replace(/\r\n/g, '\n') // Normalize line endings
        .replace(/\r/g, '\n') // Normalize Mac line endings
        .trim();

      return originalText;
    }

    async function handleCopyClick(event: Event) {
      const button = event.currentTarget as HTMLButtonElement;

      // Prevent race condition: check if button is already processing
      if (processingButtons.has(button)) {
        return;
      }

      // Check if feedback is already visible
      if (button.parentNode?.querySelector('.feedback')) {
        return;
      }

      // Mark button as processing
      processingButtons.add(button);

      // Use the improved function to get original code text
      const code = getOriginalCodeText(button);
      let success = false;

      try {
        await navigator.clipboard.writeText(code);
        success = true;
      } catch {
        try {
          success = fallbackCopy(code);
        } catch (err) {
          console.warn('Failed to copy code:', err);
        }
      }

      if (!success) {
        // Show error feedback
        const errorFeedback = document.createElement('div');
        errorFeedback.classList.add('feedback', 'error');
        // Get translated copy failed message
        const copyFailedText =
          typeof (window as any).t === 'function' ? (window as any).t('common.copyFailed') : 'Copy failed';
        errorFeedback.textContent = copyFailedText;
        button.before(errorFeedback);

        setTimeout(() => {
          errorFeedback.classList.add('show');
        }, 0);

        setTimeout(() => {
          errorFeedback.classList.remove('show');
        }, 1500);

        setTimeout(() => {
          errorFeedback.remove();
          processingButtons.delete(button);
        }, 2500);

        return;
      }

      // Create feedback element
      const feedback = document.createElement('div');
      feedback.classList.add('feedback');
      feedback.append(
        button.dataset.copied ||
          (typeof (window as any).t === 'function' ? (window as any).t('common.copySuccess') : 'Copied!')
      );
      button.before(feedback);

      // Trigger reflow to ensure transition works
      void feedback.offsetWidth;

      // Show feedback
      requestAnimationFrame(() => {
        feedback.classList.add('show');
      });

      // Hide feedback after delay
      const hideTimeout = setTimeout(() => {
        feedback.classList.remove('show');
      }, 1500);

      // Remove feedback after transition
      const removeTimeout = setTimeout(() => {
        if (parseFloat(getComputedStyle(feedback).opacity) <= 0) {
          feedback.remove();
          processingButtons.delete(button);
        }
      }, 2500);

      // Cleanup function
      const cleanup = () => {
        feedback.classList.remove('show');
        clearTimeout(hideTimeout);
        clearTimeout(removeTimeout);
        // Schedule removal
        setTimeout(() => {
          feedback.remove();
          processingButtons.delete(button);
        }, 500);
      };

      // Handle button blur
      const blurHandler = () => {
        cleanup();
        button.removeEventListener('blur', blurHandler);
      };
      button.addEventListener('blur', blurHandler);

      // Handle transition end
      const transitionEndHandler = () => {
        if (parseFloat(getComputedStyle(feedback).opacity) <= 0) {
          feedback.remove();
          processingButtons.delete(button);
          feedback.removeEventListener('transitionend', transitionEndHandler);
          feedback.removeEventListener('transitioncancel', transitionEndHandler);
        }
      };
      feedback.addEventListener('transitionend', transitionEndHandler);
      feedback.addEventListener('transitioncancel', transitionEndHandler);
    }

    function attachCopyHandlers(root: Document | Element) {
      root.querySelectorAll?.('.expressive-code .copy button').forEach((button) => {
        // Remove old listeners by cloning (won't affect our new ones)
        const newButton = button.cloneNode(true) as HTMLButtonElement;
        button.parentNode?.replaceChild(newButton, button);
        // Add our fixed handler
        newButton.addEventListener('click', handleCopyClick);
      });
    }

    // Initial attachment
    attachCopyHandlers(document);

    // Watch for new code blocks added to the DOM
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node instanceof Element) {
            attachCopyHandlers(node);
          }
        });
      });
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });

    // Re-attach on Astro page transitions
    document.addEventListener('astro:page-load', () => {
      attachCopyHandlers(document);
    });

    // Also handle astro:after-swap
    document.addEventListener('astro:after-swap', () => {
      attachCopyHandlers(document);
    });
  });
</script>

<style>
  /* Add error styling for failed copy feedback */
  .expressive-code .copy .feedback.error {
    color: #ef4444;
    background-color: #fee2e2;
    border-color: #fca5a5;
  }
</style>
